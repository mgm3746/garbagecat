error.cms.concurrent.mode.failure=Concurrent mode failure. The concurrent collection of the old generation or Perm/Metaspace did not finish before the old generation or Perm/Metaspace became full. The JVM initiates a full GC using a slow (single threaded) serial collector in an attempt to free space. There is not enough space in the old generation to support the rate of promotion from the young generation or in the Perm/Metaspace to support the rate of Perm/Metaspace usage. The concurrent low pause collector measures the rate at which the the old generation is filling and the amount of time between collections and uses this historical data to calculate when to start the concurrent collection (plus adds some padding) so that it will finish just in time before the old generation becomes full. Possible causes: (1) The heap is too small. (2) There is a change in application behavior (e.g. a load increase) that causes the young promotion rate to exceed historical data. If this is the case, the concurrent mode failures will happen near the change in behavior, then after a few collections the CMS collector will adjust based on the new promotion rate. Performance will suffer for a short period until the CMS collector recalibrates. Use -XX:CMSInitiatingOccupancyFraction=NN (default 92) to handle changes in application behavior; however, the tradeoff is that there will be more collections. (3) The application has large variances in object allocation rates, causing large variances in young generation promotion rates, leading to the CMS collector not being able to accurately predict the time between collections. Use -XX:CMSIncrementalSafetyFactor=NN (default 10) to start the concurrent collection NN% sooner than the calculated time. (4) There is premature promotion from the young to the old generation, causing the old generation to fill up with short-lived objects. The default value for -XX:MaxTenuringThreshold for the CMS collector is 0, meaning that objects surviving a young collection are immediately promoted to the old generation. Use -XX:MaxTenuringThreshold=32 to allow more time for objects to expire in the young generation. (5) If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size, moving to the G1 collector which compacts the young and old generation during evacuation, or doing heap dump analysis to determine if there is any unintended object retention that can be addressed to decrease heap demands. (6) The Perm/Metaspace fills up during the CMS cycle. Increase the Perm/Metaspace size. For example: -XX:PermSize=256M -XX:MaxPermSize=256M (Perm) or -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M (Metaspace).
error.cms.concurrent.mode.interrupted=The concurrent collection of the old generation was interrupted by user requested gc (e.g. System.gc(), JVMTI ForceGarbageCollection) or serviceability requested gc (JVMTI ForceGarbageCollection, Heap Inspection, Heap Dump).
error.cms.promotion.failed=CMS promotion failed. The old generation has available space, but it is not contiguous. The concurrent low pause collector does not compact, so when fragmentation becomes an issue the slow (single-threaded) serial collector is invoked to compact the heap. To avoid fragmentation, increase the heap size, move to the G1 collector which compacts the young and old generation during evacuation, or do heap dump analysis to determine if there is any unintended object retention that can be addressed to decrease heap demands.
error.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. Enable compressed class pointers with -XX:+UseCompressedClassPointers, so references can be compressed to 32 bits, allowing class pointer sizes on the order of 32-bit.
error.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Disable compressed class pointers with -XX:-UseCompressedClassPointers, as compressed object references should not be used on heaps >= 32G.
error.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
error.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. Enable compressed object references with -XX:+UseCompressedOops, so references can be compressed to 32 bits, allowing heap sizes on the order of 32-bit.
error.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Disable compressed object references with -XX:-UseCompressedOops, as compressed object references should not be used on heaps >= 32G.
error.explicit.gc.not.concurrent=Add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC.
error.explicit.gc.serial.cms=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded CMS_SERIAL_OLD collector to be invoked. Either add -XX:+DisableExplicitGC to disable explicit garbage collection, or add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently. Do not use -XX:+DisableExplicitGC if the application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection.
error.explicit.gc.serial.g1=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded G1_FULL_GC collector to be invoked. Either add -XX:+DisableExplicitGC to disable explicit garbage collection, or add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently. Do not use -XX:+DisableExplicitGC if the application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid these serial collections.
error.gc.time.limit.exceeded=The garbage collection overhead limit was reached. This happens when 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered. This feature is a throttle to prevent applications from running for an extended period of time while making little or no progress because the heap is too small. If desired, this feature can be disabled with the -XX:-UseGCOverheadLimit option (e.g. to avoid "OutOfMemoryError: GC overhead limit exceeded", which does not initiate a heap dump when using -XX:+HeapDumpOnOutOfMemoryError, hoping to reach "OutOfMemoryError: Java heap space", which will trigger a heap dump with -XX:+HeapDumpOnOutOfMemoryError).
error.g1.evacuation.failure=A G1_YOUNG_PAUSE, G1_MIXED_PAUSE, and/or G1_YOUNG_INITIAL_MARK collection cannot happen due to "to-space exhausted". There is not enough free space in the heap for survived and/or promoted objects, and the heap cannot be expanded. This is a very expensive operation. The Collection Set (CSet) and Remember Set (RSet) are fully re-scanned to understand the heap status, and the collector's ergonomics attempt to resolve the issue by dynamically re-sizing heap regions. If it cannot, it invokes a G1_FULL_GC in an attempt to reclaim enough space to continue. All of the following are possible resolutions: (1) Increase the heap size. (2) Increase -XX:G1ReservePercent (default 10%) and the heap size to increase the amount of to-space reserve memory. For, example, if you increase the reserve by 5% (to 15), you would also need to increase the heap size by 5%. (3) Reduce the -XX:InitiatingHeapOccupancyPercent (default 45) to start the marking cycle earlier. For example: -XX:InitiatingHeapOccupancyPercent=40. (4) Increase the number of parallel marking threads with -XX:ConcGCThreads. For example: -XX:ConcGCThreads=16. To determine which option is most appropriate, do analysis with ergonomic logging enable with the -XX:+PrintAdaptiveSizePolicy option.
error.metaspace.allocation.failure=Metaspace allocation failure. The Metaspace is not able to be resized, and the JVM is doing full, serial collections attempting to free Metaspace. The class metadata or compressed class pointers space is undersized, or there is a Metaspace leak. Increase the class metadata and compressed class pointers spaces to sufficiently large values to observe if there is a runaway leak or Metaspace usage levels off. For example, the following options will result in a 512M space for class metadata and 1G space for compressed class pointers: -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -XX:CompressedClassSpaceSize=1G.
error.physical.memory=The memory allocated to the heap and perm/metaspace is greater than the physical memory. This can lead to swapping, which is very bad for Java performance. Either increase physical memory or decrease heap and/or perm/metaspace size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Perm/Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.serial.gc=A SERIAL collector is being invoked. SERIAL collectors are single-threaded, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, tune to avoid serial collections.
error.serial.gc.cms=The CMS_SERIAL_OLD collector is being invoked for one of the following reasons: (1) Fragmentation. The concurrent low pause collector does not compact. When fragmentation becomes an issue a serial collection compacts the heap. If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size. (2) Resizing Perm/Metaspace. If Perm/Metaspace occupancy is near Perm/Metaspace allocation, the cause is likely Perm/Metaspace. Perm/Metaspace resizing can be avoided by setting the minimum Perm/Metaspace size equal to the the maximum Perm/Metaspace size. For example: -XX:PermSize=256M -XX:MaxPermSize=256M (Perm) or -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M (Metaspace). (3) Undetermined reasons. Possibly the JVM requires a certain amount of heap or combination of resources that is not being met, and consequently the concurrent low pause collector is not used despite being specified with the -XX:+UseConcMarkSweepGC option. The CMS_SERIAL_OLD collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. For optimal performance, tune to avoid serial collections.
error.serial.gc.g1=The G1_FULL_GC collector is being invoked due to the Old space or Perm/Metaspace filling up. Old space causes: (1) It is filled with humongous objects. Humongous objects can only be collected by the G1_FULL_GC collector. (2) The heap is swamped before the marking cycle is able to complete and a mixed collection reclaim space. Reduce the -XX:InitiatingHeapOccupancyPercent (default 45) to start the marking cycle earlier. For example: -XX:InitiatingHeapOccupancyPercent=40. (3) The heap is simply too small, (4) Bugs in JDK7 that cause G1 Full GC collections. For example: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8030849. The G1_FULL_GC collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. For optimal performance, tune to avoid serial collections.
error.serial.gc.parallel=The PARALLEL_SERIAL_OLD (single-threaded) collector is being invoked. Add -XX:+UseParallelOldGC to use the more efficient PARALLEL_OLD_COMPACTING collector added in JDK 6.
error.unidentified.log.lines.preparse=Unidentified log line(s). Try running with the -p (preparsing) option.   
info.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:+UseCompressedClassPointers).  
info.comp.class.size.not.set=When UseCompressedOops and UseCompressedClassesPointers (JDK 1.8 u40+) are enabled (default) the Metaspace reported in the GC logging is the sum of two native memory spaces: (1) class metadata. (2) compressed class pointers. It is recommended to explicitly set the compressed class pointers space. For example: -XX:CompressedClassSpaceSize=1G.
info.cruft.exp.gc.inv.con.and.unl.cla=The option -XX:-ExplicitGCInvokesConcurrentAndUnloadsClasses is unnecessary and can be removed because explicit garbage collection is disabled with -XX:+DisableExplicitGC.
info.first.timestamp.threshold.exceeded=First timestamp is greater than threshold. Partial log file or unrecognized logging format.
info.gc.log.file.rotation.disabled=GC log file rotation is disabled (-XX:-UseGCLogFileRotation). Consider enabling rotation to protect disk space.
info.instrumentation=Instrumentation is being used (-javaagent).
info.native=Native library is being used (-agentpath).
info.print.fls.statistics=The -XX:PrintFLSStatistics option is being used. The additional data output with this option is not typically needed and adds significant logging overhead. If there is not a good use case for using this option, remove it.
info.swapping=Some swap space used when the JVM started. This is not necessarily bad, as it is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. Swapping is very bad for Java performance, so it may be worth verifying the Java process is not swapping.
info.unidentified.log.line.last=Last log line not identified. This is typically caused by the gc log being copied while the JVM is in the middle of logging an event, resulting in truncated logging. If it is not due to truncated logging, report the unidentified logging line: https://github.com/mgm3746/garbagecat/issues.
warn.application.stopped.time.missing=-XX:+PrintGCApplicationStoppedTime missing. Required to determine overall throughput and identify throughput and pause issues not related to garbage collection, as many JVM operations besides garbage collection require all threads to reach a safepoint to execute.
warn.biased.locking.disabled=Biased locking is a threading optimization that benefits objects that are only locked by a single thread. This is the typical use case, and this option is enabled by default. Remove -XX:-UseBiasedLocking unless testing has shown that disabling biased locking improves performance.
warn.bytecode.compile.background.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete. 
warn.bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
warn.bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
warn.class.histogram=Class histogram output due to one of the following options: -XX:+PrintClassHistogram, -XX:+PrintClassHistogramBeforeFullGC, -XX:+PrintClassHistogramAfterFullGC. These are heavyweight options that can output tens of thousands of logging lines and have limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this output, do not enable it.
warn.class.unloading.disabled=Class unloading is disabled with -XX:-ClassUnloading. Replace with -XX:+ClassUnloading to unload unreachable classes to collect Perm/Metaspace.
warn.cms.class.unloading.disabled=CMS collection of Perm/Metaspace is disabled with -XX:-CMSClassUnloadingEnabled. Replace with -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle and avoid Perm/Metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.class.unloading.not.enabled=The CMS collector does not always collect Perm/Metaspace by default (e.g. prior to JDK 1.8). Add -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle and avoid Perm/Metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.inc.mode.with.init.occup.fract=When the CMS collector is run in incremental mode, the CMS initiating occupancy fraction is ignored. Remove one of the following options: (1) -XX:+CMSIncrementalMode, (2) -XX:CMSInitiatingOccupancyFraction=<n>.
warn.cms.incremental.mode=The CMS collector is being run in incremental mode. Concurrent phases are periodically stopped so application threads can run. This is useful on systems with 1-2 processors that cannot afford to dedicate cpu to the concurrent phases. Remove -XX:+CMSIncrementalMode if > 2 cpu/cores.
error.cms.new.serial.old=Add -XX:+UseConcMarkSweepGC to use the CMS collector for the old generation. When -XX:+UseParNewGC is used alone the CMS collector is only used to collect the young generation, and the older, slower serial collector is used to collect the old generation.
warn.cms.par.new.disabled=The PAR_NEW collector is disabled with -XX:-UseParNewGC, resulting in the SERIAL_NEW collector being used instead. Serial collectors are single-thread, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, the PAR_NEW collector should be enabled with -XX:+UseParNewGC.
warn.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. If the heap is < 32G, enable compressed class pointers with -XX:+UseCompressedClassPointers so references can be compressed to 32 bits, allowing class pointer sizes on the order of 32-bit.
warn.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. If the heap is < 32G, enable compressed object references with -XX:+UseCompressedOops so references can be compressed to 32 bits, allowing heap sizes on the order of 32-bit.
warn.explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection has been disabled with -XX:+DisableExplicitGC.
warn.explicit.gc.disabled=Explicit garbage collection has been disabled with -XX:+DisableExplicitGC. That is fine if the JVM is not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible the application depends on explicit garbage collection in some other way. If explicit garbage collection is required, remove -XX:+DisableExplicitGC and set sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 hour. Also add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently if using the CMS or G1 collectors. For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000 -XX:+ExplicitGCInvokesConcurrent.
warn.explicit.gc.jvmti=The JVM Tools Interface (TI) API is being called (e.g. by some tool) to explicitly invoke garbage collection.
warn.explicit.gc.parallel=Explicit garbage collection, i.e. calls to System.gc(), is causing the PARALLEL_OLD_COMPACTING collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if the application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection.
warn.explicit.gc.serial=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded SERIAL_OLD collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if the application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection.
warn.explicit.gc.serial.parallel=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded PARALLEL_SERIAL_OLD collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if the application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection.
warn.gc.log.file.num.rotation.disabled=Number of GC log files is defined (-XX:NumberOfGCLogFiles), yet GC log file rotation is disabled. Either remove -XX:NumberOfGCLogFiles or enable GC log file rotation with -XX:+UseGCLogFileRotation.
warn.gc.stopped.ratio=A significant amount of stopped time (>20%) is not GC related. Check for inverted parallelism, debugging enabled, or other JVM operations that require a safepoint: Deoptimization, PrintThreads, PrintJNI, FindDeadlock, ThreadDump, EnableBiasLocking, RevokeBias, HeapDumper, GetAllStackTrace.
warn.heap.dump.initiated.gc=A full garbage collection was initiated by a heap dump request. A heap dump significantly impacts JVM performance and should be limited to troubleshooting issues that require this heavyweight data.
warn.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error. 
warn.heap.dump.on.oome.missing=Add -XX:+HeapDumpOnOutOfMemoryError. This option does not impact performance (until the heap is actually written out); it is simply a flag to indicate that a heap dump should be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
warn.heap.inspection.initiated.gc=A tool such as Flight Recorder is initiating full garbage collections in order to monitor heap usage. If monitoring is excessive, it can significantly impact JVM performance (throughput).
warn.heap.min.not.equal.max=For production environments, it is recommended to set the minimum heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
warn.jdk7.tiered.compilation.enabled=Consider removing -XX:+TieredCompilation. It is known to cause performance issues with JDK7 (http://bugs.java.com/view_bug.do?bug_id=7159766). It is enabled by default in JDK8, where the issues affecting JDK7 appear to have been fixed. 
warn.metaspace.min.not.equal.max=For production environments, it is recommended to set the minimum Metaspace size (-XX:MetaspaceSize) and maximum Metaspace size (-XX:MaxMetaspaceSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the Metaspace. (2) If using large pages, memory is reserved for the JVM based on the maximum Metaspace size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M.
warn.metaspace.size.not.set=The Metaspace size should be explicitly set. The Metaspace size is unlimited by default and will auto increase in size up to what the OS will allow, so not setting it can swamp the OS. Explicitly set the Metaspace size. For example: -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M.
warn.perm.metaspace.size.not.set=The permanent generation (JDK7 and earlier) or Metaspace (starting JDK8) size should be explicitly set. The default permanent generation size is very small (e.g. 64M in server mode), so not setting it can lead to OutOfMemoryError. The Metaspace size is unlimited by default and will auto increase in size up to what the OS will allow, so not setting it can swamp the OS. Explicitly set the permanent generation size (e.g. -XX:PermSize=128M -XX:MaxPermSize=128M) or Metaspace size (e.g. -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M).
warn.perm.min.not.equal.max=For production environments, it is recommended to set the minimum permanent generation size (-XX:PermSize) and maximum permanent generation size (-XX:MaxPermSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the permanent generation space. (2) If using large pages, memory is reserved for the JVM based on the maximum permanent generation size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -XX:PermSize=256M -XX:MaxPermSize=256M.
warn.perm.size.not.set=The permanent generation size should be explicitly set. The default permanent generation size is very small (e.g. 64MB in server mode), so not setting it can lead to OutOfMemoryError. Explicitly set the permanent generation size. For example: -XX:PermSize=128M -XX:MaxPermSize=128M.
warn.print.gc.application.concurrent.time=Remove -XX:+PrintGCApplicationConcurrentTime. It is redundant, as the same information can be calculated from the GC logging timestamps and durations. It adds overhead with no analysis value.
warn.print.class.histogram=The -XX:+PrintClassHistogram option will cause a class histogram to be output when a thread dump is taken. It is a heavyweight option that forces a full collection and can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.class.histogram.before.full.gc=The -XX:+PrintClassHistogramBeforeFullGC option will cause a class histogram to be output before every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.class.histogram.after.full.gc=The -XX:+PrintClassHistogramAfterFullGC option will cause a class histogram to be output after every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.commandline.flags=Add -XX:+PrintCommandLineFlags to output the JVM command line options at the beginning of the gc log. This is critical information for gc analysis.
warn.print.gc.cause.disabled=Printing trigger information is disabled with -XX:-PrintGCCause. Typically you want to enable it: -XX:+PrintGCCause. Or remove the option if using JDK8, where it is enabled by default.
warn.print.gc.cause.missing=Add -XX:+PrintGCCause to print trigger information with JDK7. For example: "GC pause (G1 Evacuation Pause) (young)" vs. "GC pause (young)". Enabled by default in JDK8.
warn.print.gc.details.disabled=PrintGCDetails is disabled. This is a standard recommended logging option that outputs details needed for gc analysis. Replace -XX:-PrintGCDetails with -XX:+PrintGCDetails. Or, if both -XX:-PrintGCDetails and -XX:+PrintGCDetails are specified, remove -XX:-PrintGCDetails. 
warn.print.gc.details.missing=Add -XX:+PrintGCDetails. This is a standard recommended logging option that outputs details needed for gc analysis.
warn.print.heap.at.gc=The -XX:+PrintHeapAtGC option is enabled. The additional data output with this option is not being used for analysis, so it is extra logging overhead. If there is not a good use case for enabling this option, remove it.
warn.print.reference.gc.enabled=Remove -XX:+PrintReferenceGC. garbagecat will not parse logs with this option, resulting in many unidentified log lines. It is not a standard recommended gc logging option and is typically only enabled for special analysis. If there is no reason to use it, remove it for less verbose logging.
warn.print.string.dedup.stats.enabled=Consider removing -XX:+PrintStringDeduplicationStatistics. It is not a standard recommended gc logging option and is typically only enabled for special analysis. If there is no reason to use it, remove it for less verbose logging.
warn.print.tenuring.distribution=The -XX:+PrintTenuringDistribution option is enabled. The additional data output with this option is not being used for analysis, so it is extra logging overhead. If there is not a good use case for enabling this option, remove it.
warn.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
warn.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000).
warn.rmi.dgc.not.managed=Many environments (e.g. JBoss versions prior to EAP6) cause the RMI subsystem to be loaded. RMI manages Distributed Garbage Collection (DGC) by calling System.gc() to clean up unreachable remote objects, resulting in unnecessary major (full) garbage collection that can seriously impact performance. The default interval changed from 1 minute to 1 hour in JDK6 update 45. DGC is required to prevent memory leaks when making remote method calls or exporting remote objects like EJBs; however, test explicitly setting the DGC client and server intervals to longer intervals to minimize the impact of explicit garbage collection. For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC.
warn.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
warn.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000).
warn.thread.stack.size.large=The thread stack size is on the large side (>= 1024k). Typical values are 128k (32-bit) or 256k (64-bit). If the JVM is 32-bit, consider testing to confirm a large thread stack size is needed. This is not an issue on 64-bit unless the unused memory results in physical memory exhaustion and swapping; however, 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.thread.stack.size.not.set=If the JVM is 32-bit, consider explicitly setting the thread stack size with the -Xss (n/a Solaris) or -XX:ThreadStackSize option. The default size is typically much larger than needed. This is not an issue on 64-bit unless the unused memory results in physical memory exhaustion and swapping; however, 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.trace.class.unloading=The -XX:+TraceClassUnloading option is enabled, causing class unloading information to be output. This data is not being used for analysis. If there is not a good use case for enabling this option, remove it or disable (-XX:-TraceClassUnloading) it.
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/garbagecat/issues. 